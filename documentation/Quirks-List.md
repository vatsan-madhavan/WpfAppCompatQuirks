# `System.AppContext` based Application Compatibility switches in WPF

This is a list of all `System.AppContext` base application compatibility switches present in WPF today, along with their defaults and related documentation. 


| Switch Name                              | Full Name                                | Default Value                            | Comments                                 |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
| Switch.MS.Internal.DoNotUseCulturePreservingDispatcherOperations | MS.Internal.BaseAppContextSwitches.DoNotUseCulturePreservingDispatcherOperations | true if tfm <= net452<br>false otherwise<br><br>[feature is on when tfm > net452] | Starting .NET 4.6, ExecutionContext tracks Thread.CurrentCulture and Thread.CurrentUICulture, which would be restored<br> to their respective previous values after a call to ExecutionContext.Run. This behavior is undesirable within the<br> Dispatcher - various dispatcher operations can run user code that can in turn set Thread.CurrentCulture or<br> Thread.CurrentUICulture, and we do not want those values to be overwritten with their respective previous values.<br> To work around the new ExecutionContext behavior, we introduce CulturePreservingExecutionContext for use within<br> Dispatcher and DispatcherOperation. WPF in .NET 4.6 & 4.6.1 shipped with buggy behavior - each DispatcherOperation<br> ends with all modificaitons to culture infos being reverted.Though unlikely, if some applications targeting 4.6 or<br> above might have taken a dependence on this bug, we provide this compatiblity switch that can be enabled by the application. |
| Switch.MS.Internal.UseSha1AsDefaultHashAlgorithmForDigitalSignatures | MS.Internal.BaseAppContextSwitches.UseSha1AsDefaultHashAlgorithmForDigitalSignatures | true if tfm <= net47<br>false otherwise <br><br>[feature is enabled when tfm > net47] | PacakageDigitalSignatureManager.DefaultHashAlgorithm is now SHA256.  Setting this flag will make it SHA1 as it is in legacy scenarios prior to .NET 4.7.1. |
| Switch.MS.Internal.DoNotInvokeInWeakEventTableShutdownListener | MS.Internal.BaseAppContextSwitches.DoNotInvokeInWeakEventTableShutdownListener | false [feature is always enabled by default] | Allowing developers to turn off the Invoke added by DDVSO:543980 as there are compat issues with timing during shutdown for some applications. |
| Switch.MS.Internal.EnableWeakEventMemoryImprovements | MS.Internal.BaseAppContextSwitches.EnableWeakEventMemoryImprovements | false [feature is always enabled by default] | Enable/disable various perf and memory improvements related to WeakEvents |
| Switch.MS.Internal.EnableCleanupSchedulingImprovements | MS.Internal.BaseAppContextSwitches.EnableCleanupSchedulingImprovements | false [feature is always enabled by default] | Enable/disable heuristic for scheduling cleanup of |
| Switch.System.Windows.Markup.DoNotUseSha256ForMarkupCompilerChecksumAlgorithm | MS.Internal.BuildTasksAppContextSwitches.DoNotUseSha256ForMarkupCompilerChecksumAlgorithm | true if tfm <= net471<br>false otherwise <br><br>[feature enabled when tfm > net471] | The WPF MarkupCompiler provides compilation services for XAML markup files. In the .NET Framework 4.7.1 and earlier versions, the default hash algorithm used for checksums was SHA1. Due to recent security concerns with SHA1, this default has been changed to SHA256 starting with the .NET Framework 4.7.2. This change affects all checksum generation for markup files during compilation. |
| Switch.System.Windows.DoNotScaleForDpiChanges | MS.Internal.CoreAppContextSwitches.DoNotScaleForDpiChanges | true if tfm <= net461<br>false otherwise<br><br>[feature is enabled when tfm > net461] | Determines whether DPI changes occur on a per-system (a value of false) or per-monitor basis (a value of true). |
| Switch.System.Windows.Input.Stylus.DisableStylusAndTouchSupport |                                          |                                          | Switch to enable WPF support for the WM_POINTER based stylus/touch stack |
| Switch.System.Windows.Media.ImageSourceConverter.OverrideExceptionWithNullReferenceException |                                          | true if tfm <= net462<br>false otherwise<br><br>[feature is enabled when tfm > net462] | Switch to enable the correct exception being thrown in ImageSourceConverter.ConvertFrom instead of NullReferenceException |
| Switch.System.Windows.Diagnostics.DisableDiagnostics |                                          | false [feature is always enabled by default] | Switch to disable diagnostic features    |
| Switch.System.Windows.Diagnostics.AllowChangesDuringVisualTreeChanged |                                          | false [feature is always enabled by default] | Switch to allow changes during a VisualTreeChanged event |
| Switch.System.Windows.Input.Stylus.DisableImplicitTouchKeyboardInvocation" |                                          | false [feature is always enabled by default] | Switch to disable automatic touch keyboard invocation on focus of a control |
| Switch.UseLegacyAccessibilityFeatures    | MS.Internal.CoreAppContextSwitches.UseNetFx47CompatibleAccessibilityFeatures | true if tfm <= net47; false otherwise<br>features are enabled when tfm > net47 | https://github.com/microsoft/dotnet/blob/master/Documentation/compatibility/wpf-accessibility-improvements.MD |
| Switch.UseLegacyAccessibilityFeatures.2  | MS.Internal.CoreAppContextSwitches.UseNetFx471CompatibleAccessibilityFeatures | true if tfm <= net471; false otherwise<br>features are enabled when tfm > net471 | https://github.com/microsoft/dotnet/blob/master/Documentation/compatibility/wpf-accessibility-improvements-48.md |
| Switch.UseLegacyAccessibilityFeatures.3  | MS.Internal.CoreAppContextSwitches.UseNetFx472CompatibleAccessibilityFeatures | true if tfm <= net472; false otherwise<br>features are enabled when tfm > net472 | https://github.com/microsoft/dotnet/blob/master/Documentation/compatibility/wpf-accessibility-improvements-48.md |
| Switch.UseLegacyToolTipDisplay           | System.Windows.AccessibilitySwitches.UseLegacyToolTipDisplay | true if tfm <= net472; false otherwise<br>features are enabled when tfm > net472 | https://github.com/microsoft/dotnet/blob/master/Documentation/compatibility/wpf-accessibility-improvements-48.md |
| Switch.System.Windows.Controls.ItemsControlDoesNotSupportAutomation | System.Windows.AccessibilitySwitches.ItemsControlDoesNotSupportAutomation | true if tfm <= net472; false otherwise<br>features are enabled when tfm > net472 | https://github.com/microsoft/dotnet/blob/master/releases/net472/dotnet472-changes.md |
| Switch.System.Windows.Media.ShouldRenderEvenWhenNoDisplayDevicesAreAvailable | MS.Internal.CoreAppContextSwitches.ShouldRenderEvenWhenNoDisplayDevicesAreAvailable | false [feature is always enabled by default] | Desktop/Interactive Window Stations:<br>         Rendering will be throttled back/stopped when no display devices are available. For e.g., when a TS <br>         session is in WTSDisconnected state, the OS may not provide any display devices in response to our enumeration.<br>         If an application would like to continue rendering in the absence of display devices (accepting that <br>         it can lead to a CPU spike), it can set <see cref=" MS.Internal.CoreAppContextSwitches.ShouldRenderEvenWhenNoDisplayDevicesAreAvailable"/> <br>         to true.<br>     Service/Non-interactive Window Stations<br>         Rendering will continue by default, irrespective of the presence of display devices.Unless the WPF<br>         API's being used are shortlived (like rendering to a bitmap), it can lead to a CPU spike. <br>         If an application running inside a service would like to receive the 'default' WPF behavior, <br>         i.e., no rendering in the absence of display devices, then it should set<br>         <see cref="MS.Internal.CoreAppContextSwitches.ShouldNotRenderInNonInteractiveWindowStation"/> to true<br>     In pseudocode, <br>         IsNonInteractiveWindowStation = !Environment.UserInteractive<br>         IF DisplayDevicesNotFound() THEN<br>             IF IsNonInteractiveWindowStation THEN <br>                 // We are inside a SCM service<br>                 // Default = True, AppContext switch can override it to False<br>                 ShouldRender = !CoreAppContextSwitches.ShouldNotRenderInNonInteractiveWindowStation<br>             ELSE <br>                 // Desktop/interactive mode, including WTSDisconnected scenarios<br>                 // Default = False, AppContext switch can override it to True<br>                 ShouldRender = CoreAppContextSwitches.ShouldRenderEvenWhenNoDisplayDevicesAreAvailable<br>             END IF<br>         END IF |
| Switch.System.Windows.Media.ShouldNotRenderInNonInteractiveWindowStation | MS.Internal.CoreAppContextSwitches.ShouldNotRenderInNonInteractiveWindowStation | false [feature is always enabled by default] | Desktop/Interactive Window Stations:<br>         Rendering will be throttled back/stopped when no display devices are available. For e.g., when a TS <br>         session is in WTSDisconnected state, the OS may not provide any display devices in response to our enumeration.<br>         If an application would like to continue rendering in the absence of display devices (accepting that <br>         it can lead to a CPU spike), it can set <see cref=" MS.Internal.CoreAppContextSwitches.ShouldRenderEvenWhenNoDisplayDevicesAreAvailable"/> <br>         to true.<br>     Service/Non-interactive Window Stations<br>         Rendering will continue by default, irrespective of the presence of display devices.Unless the WPF<br>         API's being used are shortlived (like rendering to a bitmap), it can lead to a CPU spike. <br>         If an application running inside a service would like to receive the 'default' WPF behavior, <br>         i.e., no rendering in the absence of display devices, then it should set<br>         <see cref="MS.Internal.CoreAppContextSwitches.ShouldNotRenderInNonInteractiveWindowStation"/> to true<br>     In pseudocode, <br>         IsNonInteractiveWindowStation = !Environment.UserInteractive<br>         IF DisplayDevicesNotFound() THEN<br>             IF IsNonInteractiveWindowStation THEN <br>                 // We are inside a SCM service<br>                 // Default = True, AppContext switch can override it to False<br>                 ShouldRender = !CoreAppContextSwitches.ShouldNotRenderInNonInteractiveWindowStation<br>             ELSE <br>                 // Desktop/interactive mode, including WTSDisconnected scenarios<br>                 // Default = False, AppContext switch can override it to True<br>                 ShouldRender = CoreAppContextSwitches.ShouldRenderEvenWhenNoDisplayDevicesAreAvailable<br>             END IF<br>         END IF |
| Switch.System.Windows.DoNotUsePresentationDpiCapabilityTier2OrGreater | MS.Internal.CoreAppContextSwitches.DoNotUsePresentationDpiCapabilityTier2OrGreater | true if tfm <= net472<br>false otherwise<br><br>[feature is enabled when tfm > net472] | When set to true, WPF will not enable the compatibility breaking bug fixes associated with<br> features advertised by "Switch.System.Windows.PresentationDpiCapabilityTier2"<br> The following behavior would be turned off when this flag is set by the application:<br>     - Improvements to how HwndHost sizes child windows in response to DPI changes<br>     - Improvements to window placement during startup<br><br> The following fixes would remain unaffected:<br>     - High-DPI related accessibility fixes. |
| Switch.System.Windows.DoNotUsePresentationDpiCapabilityTier3OrGreater | MS.Internal.CoreAppContextSwitches.DoNotUsePresentationDpiCapabilityTier3OrGreater | false [feature is always enabled by default] | Reserved for future use                  |
| Switch.System.Windows.AllowExternalProcessToBlockAccessToTemporaryFiles | MS.Internal.CoreAppContextSwitches.AllowExternalProcessToBlockAccessToTemporaryFiles | false [feature is always enabled by default] |                                          |
| Switch.System.Windows.EnableLegacyDangerousClipboardDeserializationMode | MS.Internal.CoreAppContextSwitches.EnableLegacyDangerousClipboardDeserializationMode | false [feature is always enabled by default] | Malicious managed objects could be placed in the clipboard lying about its format, <br> to fix this OleConverter now restricts object deserialization in some cases.<br> When this switch is enabled behavior falls back to deserializing without restriction. |
| Switch.MS.Internal.DoNotApplyLayoutRoundingToMarginsAndBorderThickness | MS.Internal.FrameworkAppContextSwitches.DoNotApplyLayoutRoundingToMarginsAndBorderThickness | true if tfm <= net452<br>false otherwise<br><br>[feature is enabled when tfm > net452] | https://github.com/microsoft/dotnet/blob/master/Documentation/compatibility/wpf-layout-rounding-of-margins-has-changed.md |
| Switch.System.Windows.Controls.Grid.StarDefinitionsCanExceedAvailableSpace | MS.Internal.FrameworkAppContextSwitches.GridStarDefinitionsCanExceedAvailableSpace | true if tfm <= net462<br>false otherwise<br><br>[feature is enabled when tfm > net462] | https://github.com/microsoft/dotnet/blob/master/Documentation/compatibility/wpf-grid-allocation-of-space-to-star-columns.md |
| Switch.System.Windows.Controls.TabControl.SelectionPropertiesCanLagBehindSelectionChangedEvent | MS.Internal.FrameworkAppContextSwitches.SelectionPropertiesCanLagBehindSelectionChangedEvent | true if tfm <= net47<br>false otherwise<br><br>[feature is enabled when tfm > net47] | https://github.com/microsoft/dotnet/blob/master/Documentation/compatibility/wpf-tabcontrol-selectionchanged-and-selectedcontent.md |
| Switch.System.Windows.Data.DoNotUseFollowParentWhenBindingToADODataRelation | MS.Internal.FrameworkAppContextSwitches.DoNotUseFollowParentWhenBindingToADODataRelation | true if tfm <= net471<br>false otherwise<br><br>[feature is enabled when tfm > net471] | https://github.com/microsoft/dotnet/blob/master/Documentation/compatibility/wpf-MasterDetail-ADOdata-PrimaryKey.md |
| Switch.System.Windows.Controls.Text.UseAdornerForTextboxSelectionRendering | MS.Internal.FrameworkAppContextSwitches.UseAdornerForTextboxSelectionRendering | always true<br><br>[feature is always off by default; this is an opt-in only feature] | Switch to enable non-adorner based rendering of TextSelection in TextBox and PasswordBox |
| Switch.System.Windows.Baml2006.AppendLocalAssemblyVersionForSourceUri | MS.Internal.FrameworkAppContextSwitches.AppendLocalAssemblyVersionForSourceUri |                                          | Switch to enable appending the local assembly version to the Uri being set for ResourceDictionary.Source via Baml2006ReaderInternal. |
| Switch.System.Windows.Data.Binding.IListIndexerHidesCustomIndexer | MS.Internal.FrameworkAppContextSwitches.IListIndexerHidesCustomIndexer | true if net4 >= tfm <= net472<br>false otherwise<br><br>[feature is enabled when net4 > tfm > net472] | Switch to enable IList indexer hiding a custom indexer in a binding path |
| Switch.System.Windows.Controls.KeyboardNavigationFromHyperlinkInItemsControlIsNotRelativeToFocusedElement | MS.Internal.FrameworkAppContextSwitches.KeyboardNavigationFromHyperlinkInItemsControlIsNotRelativeToFocusedElement |                                          | Switch to enable keyboard navigation from a hyperlink to go to the wrong place |
| Switch.System.Windows.Automation.Peers.ItemAutomationPeerKeepsItsItemAlive | MS.Internal.FrameworkAppContextSwitches.ItemAutomationPeerKeepsItsItemAlive |                                          | Switch to opt-out of the ItemAutomationPeer weak-reference.<br> Setting this to true can avoid NRE crashes, but re-introduces some memory leaks<br> |

